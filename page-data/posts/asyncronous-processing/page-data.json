{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/asyncronous-processing","result":{"data":{"markdownRemark":{"id":"3e6b884a-a168-5b46-afcf-74c4222dbb46","html":"<blockquote>\n<p><a href=\"https://sculove.github.io/post/javascriptflow/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sculove.github.io/post/javascriptflow/</a></p>\n</blockquote>\n<h2 id=\"자바스크립트-엔진\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84\" aria-label=\"자바스크립트 엔진 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트 엔진</h2>\n<p><img src=\"https://joshua1988.github.io/images/posts/web/translation/how-js-works/js-engine-structure.png\" alt=\"자바스크립트 엔진\"></p>\n<ul>\n<li>자바스크립트는 <strong>단일 쓰레드</strong><br>\n<strong>하나의 스택</strong>만 가지고 있고, <strong>한번에 하나의 작업</strong>만 가능하다.</li>\n<li>자바스크립트 엔진은 힙(heap)과 콜 스택(call stack)으로 구성되어있다.</li>\n<li>함수가 호출되면 함수를 실행하기 위한 실행 컨텍스트를 구성하여 콜 스택에 쌓아올린다.</li>\n<li>힙에는 메모리(변수, 데이터)가 저장되고 스택에서 작업(코드)을 수행한다.</li>\n<li>콜 스택은 말 그대로 스택 구조로 되어 있어서, 선입후출 방식이다. (‘최근에 들어온 애가 먼저 나간다’)<br>\n함수가 호출되면 콜 스택에 차례로 쌓이고, 콜스택 최상단의 함수가 실행된다. 실행 중에 또 다른 함수가 호출되어 콜스택에 쌓이면 기존에 실행 중이던 함수는 잠시 중단되고 다시 최상단의 함수가 실행된다.</li>\n</ul>\n<hr>\n<h2 id=\"자바스크립트의-비동기-처리\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC\" aria-label=\"자바스크립트의 비동기 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트의 비동기 처리</h2>\n<p><img src=\"https://sculove.github.io/static/1d6eceee4c0f69326e44abe816bb9806/62da8/browser-structure.png\" alt=\"자바스크립트 비동기 처리과정\"></p>\n<ul>\n<li>하지만 비동기 처리하는 과정은 조금 다르다.</li>\n<li>실제 애플리케이션은 여러 작업을 동시에 처리하는 것처럼 보이는데, 이런 <strong>동시성</strong>을 가능하도록 하는 것이 <strong>이벤트 루프</strong>이다.</li>\n<li>비동기 작업들은 (이벤트핸들러 함수, 서버 통신 등) 모두 자바스크립트가 아닌 Web API에서 처리된다.</li>\n<li>코드 실행 중에 비동기 작업을 만나면 그 코드는 콜스택에서 바로 빠져나와 Web API로 전달된다. web api에서 작업을 완료한 뒤에 <strong>콜백함수는 큐(queue)에서 대기</strong>한다.</li>\n<li>큐에 쌓인 작업(task)들은 스택의 작업이 모두 완료되고 스택이 빈 상태가 되면, 하나씩 스택으로 이동한다.<br>\n큐는 선입선출 방식 (들어온 순서대로 나간다)</li>\n<li><strong>이벤트 루프</strong>는 스택의 작업 상태와 (비어있는지) 큐의 상태를 반복 확인한다.<br>\n=> 스택이 비면 -> 큐에서 스택으로 작업 이동 -> 스택에서 작업 실행</li>\n<li>비동기 작업은 microtask, task, animation frame 작업으로 구분된다.</li>\n<li>microtask가 task보다 먼저 실행된다.</li>\n<li>microtask가 처리된 후엔 requestAnimationFrame이 호출되고 화면이 브라우저 렌더링이 발생한다.</li>\n<li>microtask에는 <code class=\"language-text\">mutationObserver</code>와 <code class=\"language-text\">promise</code>가 해당된다.</li>\n</ul>","fields":{"slug":"/posts/asyncronous-processing","tagSlugs":null},"frontmatter":{"date":"2020-07-29 15:10:00","description":"자바스크립트 엔진과 비동기처리 과정","tags":null,"title":"JS | 자바스크립트의 비동기 처리","socialImage":null}}},"pageContext":{"slug":"/posts/asyncronous-processing"}},"staticQueryHashes":["251939775","401334301","825871152"]}