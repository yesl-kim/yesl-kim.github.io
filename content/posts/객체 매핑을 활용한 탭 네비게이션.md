---
title: "객체 매핑을 활용한 2depth 탭 네비게이션"
date: "2020-05-22 19:43:00"
template: "post"
draft: true
slug: "wikea-code"
category: "project"
tags:
  - "회고"
description: "인테리어 가구 쇼핑몰, 위케아 프로젝트 회고록"
---

![react로 구현한 GNB 최종 결과물](https://github.com/yesl-kim/yesl-kim.github.io/blob/develop/images/wikea-tab-navigation.gif)

## 기존 코드 분석

- 2depth 구조

- 상위 카테고리 `<li>` 의 자식요소로 그에 대응하는 하위 카테고리 메뉴 위치  
  `nav > li > (nav > li ...)`

- 상위 카테고리 클릭시 클래스명으로 DOM 제어

- **하위 카테고리 `<nav>`에 aria-hidden 속성**  
  보조 기술 사용자에게 혼란을 주지 않기 위해 화면에 보이지 않는 하위 카테고리에 `{aria hidden: true}` 속성 부여

  > aria hidden  
  > 스크린 리더와 같은 보조 기술에 탐색될지 말지를 정하는 속성  
  > 기본값은 undefined  
  > 화면에 시각적으로 보이지 않는 요소(display : block 혹은 visibillity : hidden) 는 보조기술에도 감지되지 않는다.  
  > 화면에 시각적으로 렌더링되지 않지만 명시적으로 숨겨지지 않는 요소는 여전히 접근성 트리에 존재 (overflow: hidden으로 가려지는 요소)  
  > 속성을 부여한 요소와 하위요소 모두 접근성 트리에서 제거

## 기능 구현

### 데이터 요청

- `{상위 카테고리 : [ ...하위 카테고리 ]}` 형태로 데이터 가공하기

```js
{
	category : [{
		"id": 1,
		"korean_name": "상위 카테고리명",
		"english_name": "category name",
		"sub_category": [{
			"id": 1,
			"korean_name": "하위 카테고리명",
			"english_name": "category name",
		}, {..}]
	}, {..}]
}
```

```js
constructor() {
	super();
	this.state = {
		categories: [],
		activeCategory: '',
		isSubMenuOn: false,
	};
	this.subCategories: []
}

async componentDidMount() {
	const jsonMenus = await fetch(API.CATEGORY)
	const menus = await jsonMenus.json();

	// 데이터 응답이 완료되면 [{ 상위 카테고리 : [ ...하위 카테고리] }]의 형태로 subCategories에 할당
	this.setState({categories : menus.category });
	this.subCategories = menus.category.reduce( (subCategory, {english_name, sub_category}) => {
		subCategory[korean_name] = sub_category;
		return subCategory;
	}, {} );
}
```

### 네비게이션 탭 기능 구현

- 상위 카테고리 클릭시, 상위 카테고리 영문 명을 인자로 받아 state `activeCategory` 에 저장하는 함수 `handleSubNavOn` 호출
- `this.subCategories[this.state.activeCategory]` 를 하위 카테고리 컴포넌트로 전달하여 매핑

```jsx
handleSubNavOn = (name) => {
    this.setState({
      isSubCategoryOn: true,
      activeCategory: name,
    });
  };

render() {
    const { sideModalOn, handleSideModalOn } = this.props;
    const {
      isSubCategoryOn,
      activeCategory,
      categories,
    } = this.state;

    return (
      <SideModal>
        ...
        <div className="main_nav_box">
          <AsideNav
            type="main"
            on={isSubCategoryOn}
            title="모든 제품"
            list={categories}
            handleClick={this.handleSubNavOn}
          />
					...
          {isSubCategoryOn && (
            <AsideNav
              type="sub"
              on={isSubCategoryOn}
              title={activeSubCategory}
              list={this.subCategories[activeSubCategory]}
            />)}
					...
        </div>
      </SideModal>
    );
  }
}
```

```jsx
class AsideNav extends Component {
	...

  render() {
    const { on, type, title, list, handleClick } = this.props;

    return (
      <nav
        className={on ? `aside_nav ${type}_menu on` : `aside_nav ${type}_menu`}
      >
        <h2 className="aside_nav_title">{title}</h2>
        <ul aria-label={`${title} 하위 메뉴`} className="menu_container">
          {!!list.length &&
            list.map((item, idx) => (
              <li
                key={item.id}
                role="button"
                onClick={
                  type === 'main'
                    ? () => handleClick(item.english_name)
                    : () => this.goToSubCat(item.english_name)
                }
              >
                {item.korean_name}
                {type === 'main' && (
                  <i
                    className={isClicked[idx] ? 'ic-chevron on' : 'ic-chevron'}
                  />
                )}
              </li>
            ))}
        </ul>
      </nav>
    );
  }
}
```

### 새로 배운 것

- state의 초기값은 null 로
  초기값을 실제 데이터 구조 (배열이나 객체)로 하지 않고 null로 하면 && 연산자를 활용하여 조건부 렌더링할 때 훨씬 간편했다.
  빈 배열이나 빈 객체는 그 자체로는 참으로 판단되기 때문에 .length나 키값으로 접근해야 원하는 false값을 도출할 수 있는데 null은 그렇지 않기 때문이다. 또 null 은 그대로 null을 리턴해도 오류도, 화면에 의도치 않은 요소가 출력되는 것도 막을 수 있다.
  ( `{ [].length && (<>...</>) }` —→ 화면에 0 출력 —→ `{ !![].length && (<>...</>) }` 처럼 한번 더 타입 변환을 해주어야 한다. )
- aria-\* 속성

### 아쉬운 점

- 나중에 기능이 더 추가되다 보니 상위 카테고리와 하위 카테고리를 같은 컴포넌트로 가져간 것이 조금 후회되었다. 스타일은 갖지만 다른 기능들을 가지고 있는 요소였던 것 같다.
- 이 구조가 정말 좋은 것인지는 계속 의문이 남는다.
